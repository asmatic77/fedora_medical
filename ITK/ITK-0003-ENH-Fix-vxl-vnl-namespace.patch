From d67c35c548f47ac64fbaba1b2c16259fc8f2d46e Mon Sep 17 00:00:00 2001
From: Mario Ceresa <mrceresa@gmail.com>
Date: Sat, 26 Jan 2013 00:16:27 +0100
Subject: [PATCH 3/3] ENH: Fix vxl vnl namespace

Change-Id: Ia59afd061c018811aaf5690d2aa39bd895ffa582

Signed-off-by: Mario Ceresa <mrceresa@gmail.com>
---
 Modules/Core/Common/include/itkBSplineKernelFunction.h   | 16 ++++++++--------
 .../Core/Common/include/itkSpatialOrientationAdapter.h   |  6 +++---
 .../Core/Transform/include/itkSimilarity2DTransform.hxx  |  4 ++--
 .../Core/Transform/include/itkSimilarity3DTransform.hxx  |  4 ++--
 .../include/itkDisplacementFieldTransform.hxx            |  2 +-
 .../itkBSplineScatteredDataPointSetToImageFilter.hxx     |  8 ++++----
 .../include/itkCoxDeBoorBSplineKernelFunction.hxx        |  4 ++--
 Modules/IO/ImageBase/src/itkStreamingImageIOBase.cxx     |  2 +-
 Modules/Numerics/Optimizers/src/itkPowellOptimizer.cxx   |  4 ++--
 Modules/Numerics/Optimizers/src/itkSPSAOptimizer.cxx     |  2 +-
 .../include/itkWindowConvergenceMonitoringFunction.hxx   |  2 +-
 Modules/Video/Core/include/itkRingBuffer.hxx             |  2 +-
 12 files changed, 28 insertions(+), 28 deletions(-)

diff --git a/Modules/Core/Common/include/itkBSplineKernelFunction.h b/Modules/Core/Common/include/itkBSplineKernelFunction.h
index 7ebaa7b..55ef2ab 100644
--- a/Modules/Core/Common/include/itkBSplineKernelFunction.h
+++ b/Modules/Core/Common/include/itkBSplineKernelFunction.h
@@ -84,7 +84,7 @@ private:
   /** Zeroth order spline. */
   inline TRealValueType Evaluate(const Dispatch< 0 > &, const TRealValueType & u) const
   {
-    const TRealValueType absValue = vnl_math_abs(u);
+    const TRealValueType absValue = vnl_math::abs(u);
     if ( absValue  < static_cast< TRealValueType >(0.5) )
       {
       return NumericTraits< TRealValueType >::One;
@@ -102,7 +102,7 @@ private:
   /** First order spline */
   inline TRealValueType Evaluate(const Dispatch< 1 > &, const TRealValueType & u) const
   {
-    const TRealValueType absValue = vnl_math_abs(u);
+    const TRealValueType absValue = vnl_math::abs(u);
     if ( absValue  < NumericTraits< TRealValueType >::One )
       {
       return NumericTraits< TRealValueType >::One - absValue;
@@ -116,15 +116,15 @@ private:
   /** Second order spline. */
   inline TRealValueType Evaluate(const Dispatch< 2 > &, const TRealValueType & u) const
   {
-    const TRealValueType absValue = vnl_math_abs(u);
+    const TRealValueType absValue = vnl_math::abs(u);
     if ( absValue  < static_cast< TRealValueType >(0.5) )
       {
-      const TRealValueType sqrValue = vnl_math_sqr(absValue);
+      const TRealValueType sqrValue = vnl_math::sqr(absValue);
       return static_cast< TRealValueType >(0.75) - sqrValue;
       }
     else if ( absValue < static_cast< TRealValueType >(1.5) )
       {
-      const TRealValueType sqrValue = vnl_math_sqr(absValue);
+      const TRealValueType sqrValue = vnl_math::sqr(absValue);
       // NOTE: 1.0/8.0 == static_cast< TRealValueType >( 0.125 )
       return ( static_cast< TRealValueType >(9.0) - static_cast< TRealValueType >(12.0) * absValue
         + static_cast< TRealValueType >(4.0) * sqrValue ) * static_cast< TRealValueType >(0.125);
@@ -138,16 +138,16 @@ private:
   /**  Third order spline. */
   inline TRealValueType Evaluate(const Dispatch< 3 > &, const TRealValueType & u) const
   {
-    const TRealValueType absValue = vnl_math_abs(u);
+    const TRealValueType absValue = vnl_math::abs(u);
     if ( absValue  < NumericTraits< TRealValueType >::One )
       {
-      const TRealValueType sqrValue = vnl_math_sqr(absValue);
+      const TRealValueType sqrValue = vnl_math::sqr(absValue);
       return ( static_cast< TRealValueType >(4.0) - static_cast< TRealValueType >(6.0) * sqrValue
         + static_cast< TRealValueType >(3.0) * sqrValue * absValue ) / static_cast< TRealValueType >(6.0);
       }
     else if ( absValue < static_cast< TRealValueType >(2.0) )
       {
-      const TRealValueType sqrValue = vnl_math_sqr(absValue);
+      const TRealValueType sqrValue = vnl_math::sqr(absValue);
       return ( static_cast< TRealValueType >(8.0) - static_cast< TRealValueType >(12.0) * absValue + static_cast< TRealValueType >(6.0) * sqrValue
                - sqrValue * absValue ) / static_cast< TRealValueType >(6.0);
       }
diff --git a/Modules/Core/Common/include/itkSpatialOrientationAdapter.h b/Modules/Core/Common/include/itkSpatialOrientationAdapter.h
index d8d3152..887a3f1 100644
--- a/Modules/Core/Common/include/itkSpatialOrientationAdapter.h
+++ b/Modules/Core/Common/include/itkSpatialOrientationAdapter.h
@@ -42,9 +42,9 @@ inline unsigned Max3(double x, double y, double z)
 {
   const double obliquityThresholdCosineValue = 0.001;
 
-  double absX = vnl_math_abs(x);
-  double absY = vnl_math_abs(y);
-  double absZ = vnl_math_abs(z);
+  double absX = vnl_math::abs(x);
+  double absY = vnl_math::abs(y);
+  double absZ = vnl_math::abs(z);
 
   if ( ( absX > obliquityThresholdCosineValue ) && ( absX > absY ) && ( absX > absZ ) )
     {
diff --git a/Modules/Core/Transform/include/itkSimilarity2DTransform.hxx b/Modules/Core/Transform/include/itkSimilarity2DTransform.hxx
index 3ab5f13..06ca444 100644
--- a/Modules/Core/Transform/include/itkSimilarity2DTransform.hxx
+++ b/Modules/Core/Transform/include/itkSimilarity2DTransform.hxx
@@ -148,8 +148,8 @@ void
 Similarity2DTransform<TScalarType>
 ::ComputeMatrixParameters(void)
 {
-  m_Scale = vcl_sqrt( vnl_math_sqr(this->GetMatrix()[0][0])
-                      + vnl_math_sqr(this->GetMatrix()[0][1]) );
+  m_Scale = vcl_sqrt( vnl_math::sqr(this->GetMatrix()[0][0])
+                      + vnl_math::sqr(this->GetMatrix()[0][1]) );
 
   this->SetVarAngle( vcl_acos(this->GetMatrix()[0][0] / m_Scale) );
 
diff --git a/Modules/Core/Transform/include/itkSimilarity3DTransform.hxx b/Modules/Core/Transform/include/itkSimilarity3DTransform.hxx
index de97687..c1f27b4 100644
--- a/Modules/Core/Transform/include/itkSimilarity3DTransform.hxx
+++ b/Modules/Core/Transform/include/itkSimilarity3DTransform.hxx
@@ -94,7 +94,7 @@ Similarity3DTransform<TScalarType>
   // It will imply a reflection of the coordinate system.
   //
 
-  double s = vnl_math_cuberoot(det);
+  double s = vnl_math::cuberoot(det);
 
   //
   // A negative scale is not acceptable
@@ -301,7 +301,7 @@ Similarity3DTransform<TScalarType>
 {
   MatrixType matrix = this->GetMatrix();
 
-  m_Scale = vnl_math_cuberoot( vnl_det( matrix.GetVnlMatrix() ) );
+  m_Scale = vnl_math::cuberoot( vnl_det( matrix.GetVnlMatrix() ) );
 
   matrix /= m_Scale;
 
diff --git a/Modules/Filtering/DisplacementField/include/itkDisplacementFieldTransform.hxx b/Modules/Filtering/DisplacementField/include/itkDisplacementFieldTransform.hxx
index 73392b4..2400b81 100644
--- a/Modules/Filtering/DisplacementField/include/itkDisplacementFieldTransform.hxx
+++ b/Modules/Filtering/DisplacementField/include/itkDisplacementFieldTransform.hxx
@@ -336,7 +336,7 @@ const
           }
         jacobian(col, row) = val;
         // Verify it's a real number
-        if( !vnl_math_isfinite( val) )
+        if( !vnl_math::isfinite( val) )
           {
           oktosample = false;
           break;
diff --git a/Modules/Filtering/ImageGrid/include/itkBSplineScatteredDataPointSetToImageFilter.hxx b/Modules/Filtering/ImageGrid/include/itkBSplineScatteredDataPointSetToImageFilter.hxx
index 7a0ac24..2e8b780 100644
--- a/Modules/Filtering/ImageGrid/include/itkBSplineScatteredDataPointSetToImageFilter.hxx
+++ b/Modules/Filtering/ImageGrid/include/itkBSplineScatteredDataPointSetToImageFilter.hxx
@@ -615,7 +615,7 @@ BSplineScatteredDataPointSetToImageFilter<TInputPointSet, TOutputImage>
         this->m_CurrentNumberOfControlPoints[i] - this->m_SplineOrder[i];
 
       p[i] = ( point[i] - this->m_Origin[i] ) * r[i];
-      if( vnl_math_abs( p[i] - static_cast<RealType>( totalNumberOfSpans ) ) <=
+      if( vnl_math::abs( p[i] - static_cast<RealType>( totalNumberOfSpans ) ) <=
         this->m_BSplineEpsilon )
         {
         p[i] = static_cast<RealType>( totalNumberOfSpans )
@@ -760,7 +760,7 @@ BSplineScatteredDataPointSetToImageFilter<TInputPointSet, TOutputImage>
       U[i] = static_cast<RealType>( totalNumberOfSpans[i] ) *
         static_cast<RealType>( idx[i] - startIndex[i] ) /
         static_cast<RealType>( this->m_Size[i] - 1 );
-      if( vnl_math_abs( U[i] - static_cast<RealType>( totalNumberOfSpans[i] ) )
+      if( vnl_math::abs( U[i] - static_cast<RealType>( totalNumberOfSpans[i] ) )
         <= this->m_BSplineEpsilon )
         {
         U[i] = static_cast<RealType>( totalNumberOfSpans[i] ) -
@@ -866,7 +866,7 @@ BSplineScatteredDataPointSetToImageFilter<TInputPointSet, TOutputImage>
         P = ItD.Get() / ItO.Get();
         for( unsigned int i = 0; i < P.Size(); i++ )
           {
-          if( vnl_math_isnan( P[i] ) || vnl_math_isinf( P[i] ) )
+          if( vnl_math::isnan( P[i] ) || vnl_math::isinf( P[i] ) )
             {
             P[i] = 0;
             }
@@ -1094,7 +1094,7 @@ BSplineScatteredDataPointSetToImageFilter<TInputPointSet, TOutputImage>
       U[i] = static_cast<RealType>( totalNumberOfSpans[i] ) *
         static_cast<RealType>( point[i] - this->m_Origin[i] ) /
         ( static_cast<RealType>( this->m_Size[i] - 1 ) * this->m_Spacing[i] );
-      if( vnl_math_abs( U[i] - static_cast<RealType>( totalNumberOfSpans[i] ) )
+      if( vnl_math::abs( U[i] - static_cast<RealType>( totalNumberOfSpans[i] ) )
         <= this->m_BSplineEpsilon )
         {
         U[i] = static_cast<RealType>( totalNumberOfSpans[i] ) -
diff --git a/Modules/Filtering/ImageGrid/include/itkCoxDeBoorBSplineKernelFunction.hxx b/Modules/Filtering/ImageGrid/include/itkCoxDeBoorBSplineKernelFunction.hxx
index bd2fe52..d7e4b15 100644
--- a/Modules/Filtering/ImageGrid/include/itkCoxDeBoorBSplineKernelFunction.hxx
+++ b/Modules/Filtering/ImageGrid/include/itkCoxDeBoorBSplineKernelFunction.hxx
@@ -164,7 +164,7 @@ TRealValueType
 CoxDeBoorBSplineKernelFunction<VSplineOrder,TRealValueType>
 ::Evaluate( const TRealValueType &u ) const
 {
-  const TRealValueType absValue = vnl_math_abs( u );
+  const TRealValueType absValue = vnl_math::abs( u );
 
   unsigned int which;
   if( this->m_SplineOrder % 2 == 0 )
@@ -200,7 +200,7 @@ TRealValueType
 CoxDeBoorBSplineKernelFunction<VSplineOrder,TRealValueType>
 ::EvaluateNthDerivative( const TRealValueType & u, const unsigned int n ) const
 {
-  const TRealValueType absValue = vnl_math_abs( u );
+  const TRealValueType absValue = vnl_math::abs( u );
 
   unsigned int which;
   if( this->m_SplineOrder % 2 == 0 )
diff --git a/Modules/IO/ImageBase/src/itkStreamingImageIOBase.cxx b/Modules/IO/ImageBase/src/itkStreamingImageIOBase.cxx
index 0e563cd..61ce3f1 100644
--- a/Modules/IO/ImageBase/src/itkStreamingImageIOBase.cxx
+++ b/Modules/IO/ImageBase/src/itkStreamingImageIOBase.cxx
@@ -447,7 +447,7 @@ bool StreamingImageIOBase::RequestedToStream(void) const
   // This enables a 2D request from a 3D volume to get the first slice,
   // and a 4D with a 1-sized 4th dimension to equal the 3D volume
   // as well.
-  unsigned int maxNumberOfDimension = vnl_math_max( this->GetNumberOfDimensions(),
+  unsigned int maxNumberOfDimension = vnl_math::max( this->GetNumberOfDimensions(),
                                                     this->GetIORegion().GetImageDimension() );
 
   ImageIORegion ioregion(maxNumberOfDimension);
diff --git a/Modules/Numerics/Optimizers/src/itkPowellOptimizer.cxx b/Modules/Numerics/Optimizers/src/itkPowellOptimizer.cxx
index 941262a..c35297d 100644
--- a/Modules/Numerics/Optimizers/src/itkPowellOptimizer.cxx
+++ b/Modules/Numerics/Optimizers/src/itkPowellOptimizer.cxx
@@ -508,8 +508,8 @@ PowellOptimizer
     if ( fptt < fp )
       {
       double t = 2.0 * ( fp - 2.0 * fx + fptt )
-                 * vnl_math_sqr(fp - fx - del)
-                 - del *vnl_math_sqr(fp - fptt);
+                 * vnl_math::sqr(fp - fx - del)
+                 - del *vnl_math::sqr(fp - fptt);
       if ( t < 0.0 )
         {
         this->SetLine(p, xit);
diff --git a/Modules/Numerics/Optimizers/src/itkSPSAOptimizer.cxx b/Modules/Numerics/Optimizers/src/itkSPSAOptimizer.cxx
index 9e6fc71..877bdcd 100644
--- a/Modules/Numerics/Optimizers/src/itkSPSAOptimizer.cxx
+++ b/Modules/Numerics/Optimizers/src/itkSPSAOptimizer.cxx
@@ -403,7 +403,7 @@ SPSAOptimizer::ComputeGradient(
   /** Apply scaling (see below) and divide by the NumberOfPerturbations */
   for ( unsigned int j = 0; j < spaceDimension; j++ )
     {
-    gradient[j] /= ( vnl_math_sqr(scales[j]) * static_cast< double >( m_NumberOfPerturbations ) );
+    gradient[j] /= ( vnl_math::sqr(scales[j]) * static_cast< double >( m_NumberOfPerturbations ) );
     }
   /**
    * Scaling was still needed, because the gradient
diff --git a/Modules/Numerics/Optimizersv4/include/itkWindowConvergenceMonitoringFunction.hxx b/Modules/Numerics/Optimizersv4/include/itkWindowConvergenceMonitoringFunction.hxx
index 4aedf7c..3c5736f 100644
--- a/Modules/Numerics/Optimizersv4/include/itkWindowConvergenceMonitoringFunction.hxx
+++ b/Modules/Numerics/Optimizersv4/include/itkWindowConvergenceMonitoringFunction.hxx
@@ -55,7 +55,7 @@ WindowConvergenceMonitoringFunction<TScalar>
     {
     this->m_EnergyValues.pop_front();
     }
-  this->m_TotalEnergy += vnl_math_abs( value );
+  this->m_TotalEnergy += vnl_math::abs( value );
 
   this->Modified();
 }
diff --git a/Modules/Video/Core/include/itkRingBuffer.hxx b/Modules/Video/Core/include/itkRingBuffer.hxx
index 9da5a09..61ad50f 100644
--- a/Modules/Video/Core/include/itkRingBuffer.hxx
+++ b/Modules/Video/Core/include/itkRingBuffer.hxx
@@ -225,7 +225,7 @@ typename RingBuffer< TElement >::OffsetValueType
 RingBuffer< TElement >
 ::GetOffsetBufferIndex(OffsetValueType offset)
 {
-  OffsetValueType moddedOffset = vnl_math_abs(offset) % this->GetNumberOfBuffers();
+  OffsetValueType moddedOffset = vnl_math::abs(offset) % this->GetNumberOfBuffers();
   OffsetValueType signedHeadIndex = static_cast<OffsetValueType>(m_HeadIndex);
   if (offset >= 0)
     {
-- 
1.8.1

